import{_ as a,c as l,o as i,a4 as e}from"./chunks/framework.D1poPhlk.js";const q=JSON.parse('{"title":"","description":"","frontmatter":{"outline":"deep","desc":"服务治理","tags":"Service Mesh","updateTime":"2024-05-25 20:48"},"headers":[],"relativePath":"Notes/Service/什么是服务治理.md","filePath":"Notes/Service/什么是服务治理.md"}'),r={name:"Notes/Service/什么是服务治理.md"},h=e(`<h2 id="分布式治理方案" tabindex="-1">分布式治理方案 <a class="header-anchor" href="#分布式治理方案" aria-label="Permalink to &quot;分布式治理方案&quot;">​</a></h2><h3 id="服务设计" tabindex="-1">服务设计 <a class="header-anchor" href="#服务设计" aria-label="Permalink to &quot;服务设计&quot;">​</a></h3><h4 id="协议栈-序列化-参数化机制" tabindex="-1">协议栈，序列化，参数化机制 <a class="header-anchor" href="#协议栈-序列化-参数化机制" aria-label="Permalink to &quot;协议栈，序列化，参数化机制&quot;">​</a></h4><p>概述：</p><p><strong>协议栈</strong></p><p><strong>序列化</strong></p><p><strong>参数传递</strong></p><p>概述：服务框架需要支持业务本身的参数，还需要支持额外的惨呼，例如消费提供者的IP地址，消息调用链的TraceID,</p><ul><li><p>内部参数： 本地方法调用（方法的定义声明来传递参数）；线程共享参数（ThreadLocal）；业务的编排，将各个业务编排成一个责任链；BMP流程引擎。</p></li><li><p>外部参数：主要用于服务的消费者和提供者之间进行参数传递，例如分布式事务中的事务上下文信息传递，服务框架本身或者第三方服务组件需要的参数信息</p></li><li><p>防止参数互相覆盖</p></li><li><p>参数生命周期管理</p></li></ul><h4 id="服务的发布和调用" tabindex="-1">服务的发布和调用 <a class="header-anchor" href="#服务的发布和调用" aria-label="Permalink to &quot;服务的发布和调用&quot;">​</a></h4><p>概述：</p><ul><li>发布：服务发布的流程，依赖于第三方的注册中心或协调组件，常用的服务发布形式有XML（配置文件，无代码侵入），注解（代码侵入），API（需要提供整套的API服务）</li></ul><image src="./images/rpc/rpc_service_export.jpeg" height="400px" width="800px"></image><ul><li>调用：服务调用的流程，依赖于第三方的注册中心或协调组件</li></ul><image src="./images/rpc/rpc_service_import.jpeg" height="400px" width="800px"></image><ul><li><p>对等设计原则：在服务发布的时候，如果需要支持多协议的发布形式，应该支持保持多种协议的支持级别是对等的，保持一致。</p></li><li><p>启动顺序问题：由于各个服务组件不是集中式的部署，所以，服务框架应该能够支持各个组件的随时可能宕机，重启，从大的面来说就是各个组件的启动时无序的。</p></li><li><p>同步还是异步发布服务：一旦服务的数目过多，或产生一个问题就是服务的启动时间会比较长，所以针对一些非核心的服务采用异步，或者延迟发布服务。</p></li><li><p>警惕网络风暴：该问题的核心来源是注册中心如果承担过多的动态信息，会导致其会成为一个单点问题，因此需要考虑以下几个方面：</p><ul><li>哪些信息需要注册到服务注册中心，需要甄别</li><li>服务注册中心能够管理的服务上线</li><li>服务注册中心的网络带宽规划</li><li>服务注册中心的磁盘空间规划</li><li>服务注册中心的性能 以上这些信息需要做评估，得出合理的方案</li></ul></li><li><p>配置扩展：</p></li></ul><h4 id="调用模型" tabindex="-1">调用模型 <a class="header-anchor" href="#调用模型" aria-label="Permalink to &quot;调用模型&quot;">​</a></h4><p>概述：远程调用的调用模型，根据不同的业务类型选择合适的模型，普遍有以下几种模型</p><ul><li>同步调用:分为请求-响应型，消息型，请求没有响应</li><li>异步调用:</li><li>异步回调:</li><li>并行调用:</li><li>泛化调用:</li></ul><h4 id="服务配置和协调组件" tabindex="-1">服务配置和协调组件 <a class="header-anchor" href="#服务配置和协调组件" aria-label="Permalink to &quot;服务配置和协调组件&quot;">​</a></h4><p>概述：新增一个分布式的配置和协调中心，避免消费者和服务提供者直接进行交互，这样的好处在于服务提供者对消费者而言是透明的，另外就是该组件能够承担需要协调的功能，比如：发布-订阅，心跳检测，服务配置持久化等机制，其主要功能有以下几点：</p><ul><li>实例的心跳检测</li><li>服务-发布/下线时的通知机制</li><li>持久化机制</li><li>包含基本的CRUD操作的API,这样可以使得消费者，提供者或者其他服务能够管理整体的服务列表</li><li>安全机制：链路安全（连接认证机制），数据安全（数据的权限机制）</li><li>天然分布式：支持弹性伸缩，这块涉及到集群中的分布式一致性协议，例如：PAXOS，RAFT，ZAB等协议</li></ul><h3 id="容错" tabindex="-1">容错 <a class="header-anchor" href="#容错" aria-label="Permalink to &quot;容错&quot;">​</a></h3><p>概述：分布式服务系统的调用面临着几种情况：成功，超时，失败，因此对于调用发起方而言做好容错是十分关键的，因为对其而言，提供商是透明的。</p><h4 id="面临的问题与场景" tabindex="-1">面临的问题与场景 <a class="header-anchor" href="#面临的问题与场景" aria-label="Permalink to &quot;面临的问题与场景&quot;">​</a></h4><ul><li><p>通信链路层的故障：提供者和消费者之间是维持的长连接，所有可能由于网络或者来自硬件的问题，导致通信中断的情况，大致的情况可能有以下几种：</p><ul><li>被调用者宕机</li><li>网络波动产生的闪断</li><li>心跳超时</li></ul></li><li><p>服务调用失败：调用时发生的除了业务异常意外的异常</p></li><li><p>服务调用超时：调用时耗时过长，导致的超时</p></li></ul><h4 id="容错策略" tabindex="-1">容错策略 <a class="header-anchor" href="#容错策略" aria-label="Permalink to &quot;容错策略&quot;">​</a></h4><p>针对以上的不可靠场景，所以需要根据不同的业务场景进行容错，有以下几种容错策略：</p><ul><li><p>失败自动切换（Failover）</p><p>Failover策略应该是整个容错策略中使用最为广泛的一种，该策略指的是在消费者根据路由（负载均衡）策略发出调用的时候返回失败或超时等情况时，记录上次的服务地址，然后再根据负载均衡算法取一个新的服务实例进行调用（排除上次失败的地址），失败的话再执行以上步骤，直至成功，这里有几个问题是需要注意的</p><ul><li>一定需要设置Failover的次数，一般是3，否则设置过大的话，耗时过长，资源消耗过大</li><li>一般是读操作，本身就是幂等。</li><li>幂等的服务，保证不会重复提交数据等情况</li></ul></li><li><p>失败通知（FailBack）</p><p>FailBack策略指的是当收到服务方返回的异常信息，解析出错误码，然后根据错误码决定后续的执行策略，比如忽略直接返回，或者直接将异常信息交给消费者的调用方处理。</p></li><li><p>失败缓存（FailCache）</p><p>FailCache策略是失败自动恢复的一种，指的是在调用异常和超时的时候，将请求信息缓存，等到合适的时机（周期T）再用请求信息发出服务调用，其执行轨迹是，调用-》失败-》缓存-》等待时间周期T-》重试，由于是不是实时的发出请求，所有该方案指适用于对调用实时性不高的，或者是一个异步的调用，在以上策略还是调用失败，那就需要记录失败日志，然后直接返回失败。</p></li><li><p>快速失败（FailFast）</p><p>FailFast策略指的是在调用时发生失败，直接记录异常日志，忽略失败异常然后返回。</p></li><li><p>容错策略扩展</p><p>该策略是一个扩展点，用于用户自定义自己的容错策略，在设计整个容错模块的时候，有以下几点需要注意的</p><ul><li>开闭原则，对扩展的开放和修改的关闭；</li><li>配置应该是天生支持扩展，不需要用户扩展框架的schema。</li></ul></li></ul><h3 id="服务路由" tabindex="-1">服务路由 <a class="header-anchor" href="#服务路由" aria-label="Permalink to &quot;服务路由&quot;">​</a></h3><p>概述：服务路由是指在服务集群环境下，服务消费者面临的是1~N的实例，所有需要采用一定的路由算法来确定是向那个实例发出调用；在RPC中采用分布式的注册中心来动态的配置管理服务提供者的地址，消费者从注册中心获取服务实例的地址，并且注册中心支持发布-订阅的服务，这样的话，在新增和减少服务实例的弹性伸缩时能够让消费者能够动态的感知到这个变化；另外为了避免注册中心的单点问题，导致服务的不可用，所有消费会缓存服务的提供者的地址列表。</p><h4 id="负载均衡" tabindex="-1">负载均衡 <a class="header-anchor" href="#负载均衡" aria-label="Permalink to &quot;负载均衡&quot;">​</a></h4><ul><li>随机</li><li>轮询</li><li>服务调用延时</li><li>一致性hash</li><li>最小连接数</li><li>粘滞连接</li></ul><h4 id="本地路由优先策略" tabindex="-1">本地路由优先策略 <a class="header-anchor" href="#本地路由优先策略" aria-label="Permalink to &quot;本地路由优先策略&quot;">​</a></h4><ul><li>inJvm模式：该模式指的是在消费者实例中包含了一个服务的默认实现（不是MOCK），所有消费者发出远程调用的时候优先查找本地的服务实现，如果没有发现才会发出远程调用。</li><li>inNative模式：该模式指的是在消费者所在的主机/VM中包含了一个服务的实现，则优先调用本机/VM中的服务实现，没有发现才会发出远程调用。</li></ul><h4 id="路由规则" tabindex="-1">路由规则 <a class="header-anchor" href="#路由规则" aria-label="Permalink to &quot;路由规则&quot;">​</a></h4><ul><li>条件路由规则</li><li>脚本路由规则</li></ul><h4 id="路由策略的扩展" tabindex="-1">路由策略的扩展 <a class="header-anchor" href="#路由策略的扩展" aria-label="Permalink to &quot;路由策略的扩展&quot;">​</a></h4><p>在设计路由模块时，需要考虑用户自定义的路由策略，因此需要提供路由策略的可扩展点（方式有：接口，xml,spi）；</p><p>在正式的业务场景下，可能需要设置多级的路由策略，比如：</p><pre><code>* 本地配置：包括服务提供者和消费者，默认全局配置三种
* 统一注册中心管理：无论是服务提供者还是消费者，本地配置的路由策略统一注册到服务注册中心，进行集中化的配置管理
* 服务治理端的管理：由服务治理端进行变更管理,然后通知注册中心，然后再下发到服务提供者和消费中。
</code></pre><p>他们之间的优先级关系是：消费端》服务端》全局配置；</p><pre><code>* 在服务端设置路由策略：因为服务端和消费端有SLA（服务质量等级协议），就是服务端要保证暴露出的接口是能达到协议协定的，因此服务端需要根据自身的运行状态，定期的汇集运行数据，来确定是采取何种路由策略是最合理的，类似于一个对等协定。
* 在消费端设置路由策略：消费端作为调用方，是需要根据自身的业务需求来决定采用何种路由策略。
</code></pre><h3 id="流量控制" tabindex="-1">流量控制 <a class="header-anchor" href="#流量控制" aria-label="Permalink to &quot;流量控制&quot;">​</a></h3><hr><p>概述：</p><h5 id="静态流控" tabindex="-1">静态流控 <a class="header-anchor" href="#静态流控" aria-label="Permalink to &quot;静态流控&quot;">​</a></h5><p>在分布式协调系统中（注册中心），在服务启动的时候初始化一个总的阈值，然后为每一个实例按照一定的分配算法来分配各个实例的阈值，然后根据该阈值来做流量控制，该方案的最大问题是不能动态的根据实例运行期的状况来做流量控制,另外就是在增加实例或者实例宕机时需要重新计算并分配。</p><p>在这基础之上优化：在注册中心为每一个服务初始化一个流量资源池，每一个实例根据自身的情况去注册中心获取资源，这个操作是定期的（周期T），这样的话，服务实例可以根据自身的资源情况来申请资源。</p><h5 id="动态流控" tabindex="-1">动态流控 <a class="header-anchor" href="#动态流控" aria-label="Permalink to &quot;动态流控&quot;">​</a></h5><p>流控因子：</p><pre><code>* 系统资源:实例所在主机/vm的cpu使用率，内存使用率，网络带宽情况
* 应用资源:实例的进程级资源，比如JVM的堆栈内存使用情况，消息队列积压率，会话积压率
</code></pre><p>分级流控：</p><pre><code>* 不同流量的状态下（根据流控因子作为参考，多次取平均值）流控有不同的策略，根据预估的流量做出合理的流控分级策略。
</code></pre><h5 id="并发控制" tabindex="-1">并发控制 <a class="header-anchor" href="#并发控制" aria-label="Permalink to &quot;并发控制&quot;">​</a></h5><p>并发控制的目的是针对线程的并发执行数进行控制，也就是访问线程数过多，导致的资源过度的消耗，导致服务本身或者拖垮其他的服务，其实这块涉及到的还有服务的隔离（线程级别），并发控制有两种：</p><ul><li>针对服务者的全局并发控制： 在服务端针对没有个服务执行都隔离在一个单独的线程池中，设置合理的线程池数，然后针对过载的服务直接返回异常或者返回默认结果</li><li>针对消费者的单个服务的局部并发控制 消费者针对没一个单独的服务进行并行执行线程数的控制。</li></ul><h5 id="连接控制" tabindex="-1">连接控制 <a class="header-anchor" href="#连接控制" aria-label="Permalink to &quot;连接控制&quot;">​</a></h5><p>由于服务提供者和消费者都是通过长连接进行通信，所有过多的TCP长连接会占据服务提供者过多的资源，所以需要针对这块做流量控制。 服务提供者和消费者都可以针对单一服务进行连接数流控。</p><h3 id="服务降级" tabindex="-1">服务降级 <a class="header-anchor" href="#服务降级" aria-label="Permalink to &quot;服务降级&quot;">​</a></h3><hr><p>概述：</p><h4 id="容错降级-熔断降级" tabindex="-1">容错降级（熔断降级） <a class="header-anchor" href="#容错降级-熔断降级" aria-label="Permalink to &quot;容错降级（熔断降级）&quot;">​</a></h4><p>容错降级一般针对的是消费者在发起远程服务调用的时候，受网络，提供者报错等诸多原因，导致的消费者无法及时和正确的响应，所进行的降级策略，也叫做熔断降级，该降级的场景就是，一旦消费者调用服务发生超时，返回错误（异常）时进行降级策略，比如返回指定的异常，或者执行本地MOCK接口。 当然这个过程也可以和屏蔽降级的方式一样通过服务治理的管理端进行控制，流程大致和其类似。</p><h4 id="屏蔽降级" tabindex="-1">屏蔽降级 <a class="header-anchor" href="#屏蔽降级" aria-label="Permalink to &quot;屏蔽降级&quot;">​</a></h4><p>直接通过服务治理端选择降级的服务并选择降级的策略（返回null,返回指定异常，执行恩地MOCK接口），然后通知注册中心，然后通过注册中心的通知事件告知服务提供者和消费者，提供者进行更改状态为屏蔽降级，消费者更新状态为启用降级策略，根据通知的策略来进行降级。</p><h4 id="业务层降级" tabindex="-1">业务层降级 <a class="header-anchor" href="#业务层降级" aria-label="Permalink to &quot;业务层降级&quot;">​</a></h4><p>业务层降级是单体或者实例本身进行本地调用的时候进行的降级策略。</p><h3 id="分布式链路跟踪与分析" tabindex="-1">分布式链路跟踪与分析 <a class="header-anchor" href="#分布式链路跟踪与分析" aria-label="Permalink to &quot;分布式链路跟踪与分析&quot;">​</a></h3><hr><p>概述：在一个大型的系统中，一次业务的调用会经历许多的系统，比如：业务实例，消息中间件，分布式缓存，分布式服务框架，分布式存储系统；因此我们需要一种能够描述整个调用轨迹的数据信息，这样的好处有以下几点：</p><ul><li><p>故障的快速定界定位：为每一个业务日志调用新增调用链ID，然后采用分布式的日志收集器进行海量日志数据的收集，这样的话我们的业务日志就和我们的调用链动态的关联，这样的话我们可以根据调用链ID来查询日志信息，方便定位问题。</p></li><li><p>调用路径的分析：分析整个调用路径的分析，能够得到系统的瓶颈在哪儿，那块的流量比较高。</p></li><li><p>调用来源和去向分析：通过调用去向的分析，可以对服务的依赖关系进行有效梳理，</p><ul><li>应用直接和简介依赖了哪些服务</li><li>各层依赖的调用时延，QPS，成功率等性能KPI指标</li><li>识别不合理的强依赖，或者冗余依赖，反向要求开发进行依赖解耦和优化 通过对调用来源进行TOP排序，可以识别当前服务的消费来源，以及获取各消费者的QPS，平均时延，出错率等，针对特定的消费者，可以做针对性治理，例如针对某个消费中的限流降级，咯有策略修改等，保障服务的SLA。</li></ul></li></ul><h4 id="跟踪系统的设计" tabindex="-1">跟踪系统的设计 <a class="header-anchor" href="#跟踪系统的设计" aria-label="Permalink to &quot;跟踪系统的设计&quot;">​</a></h4><p>分布式消息跟踪系统的核心就是调用链，每次业务请求都生成一个全局唯一的TraceID,通过跟踪ID将不同节点间的日志串接起来，形成一个完整的日志调用链，通过对调用链日志做实时采集，汇总和大数据分析，提取各种纬度的价值数据，为系统运维和运营提供大数据的支撑。</p><image src="./images/rpc/rpc_trace.jpeg" height="400px" width="400px"></image><ol><li>调用链埋点日志生成</li><li>分布式采集和存储埋点日志</li><li>在线，离线大数据计算，对调用链数据进行分析和汇总</li><li>调用链的界面展示，排序和检索等。</li></ol><h4 id="埋点日志" tabindex="-1">埋点日志 <a class="header-anchor" href="#埋点日志" aria-label="Permalink to &quot;埋点日志&quot;">​</a></h4><image src="./images/rpc/rpc_trace1.jpeg" height="400px" width="400px"></image><h4 id="分布式采集和存储埋点日志" tabindex="-1">分布式采集和存储埋点日志 <a class="header-anchor" href="#分布式采集和存储埋点日志" aria-label="Permalink to &quot;分布式采集和存储埋点日志&quot;">​</a></h4><p>采用开源的ELK或者资源收集，存储，可视化工具集，</p><image src="./images/rpc/rpc_trace2.jpeg" height="400px" width="400px"></image><h4 id="计算和展示" tabindex="-1">计算和展示 <a class="header-anchor" href="#计算和展示" aria-label="Permalink to &quot;计算和展示&quot;">​</a></h4><p>在存储的日志进行各种纬度的实时或者离线的大数据计算分析之后，我们可以将相关的数据存储在HBASE或者关系型数据中，后期方便展示。</p><h3 id="高可用-监控机制" tabindex="-1">高可用（监控机制） <a class="header-anchor" href="#高可用-监控机制" aria-label="Permalink to &quot;高可用（监控机制）&quot;">​</a></h3><p>概述：在一个大型的分布式系统当中，会有大量的集群机器，每一台机器中都提供服务，所以一旦一个主机宕机了，但是其他相关的机器无法感知，这就会导致无效的调用，所以我们需要一套完整而健全的监控系统来监控集群的所有机器，保持其实存活的，一旦其宕机将其剔除集群，这样的话对系统而言这是一个自动调整容错的。</p><h4 id="服务状态监测" tabindex="-1">服务状态监测 <a class="header-anchor" href="#服务状态监测" aria-label="Permalink to &quot;服务状态监测&quot;">​</a></h4><ul><li>注册中心的状态监测：注册中心和服务端建立的长连接会有心跳监测的机制，这样的话，一旦注册中心发现服务端不可用，立马将其从相关的服务地址中剔除该地址，并通知相关的消费端更新本地缓存</li><li>链路有效性状态监测机制：这个机制是保证消费端和服务端之间的长连接是有效的，这是一个双向的心跳检测机制，确保，两者之间的会话是健康的。</li></ul><h4 id="服务健康度检测" tabindex="-1">服务健康度检测 <a class="header-anchor" href="#服务健康度检测" aria-label="Permalink to &quot;服务健康度检测&quot;">​</a></h4><p>服务端和消费端定期上传：服务调用时延，服务的QPS，服务调用成功率，JVM的堆内存，CPU的使用情况等到监控中心，监控中心对每一个机器，每一个服务提供者的状态，基于这些数据可以反馈给注册中心，然后调整各个端的路由策略。</p><h4 id="服务隔离" tabindex="-1">服务隔离 <a class="header-anchor" href="#服务隔离" aria-label="Permalink to &quot;服务隔离&quot;">​</a></h4><ul><li>进程隔离</li><li>VM隔离</li><li>物理机隔离</li><li>夸机柜隔离</li><li>夸机房隔离</li></ul><h4 id="可靠性保证组件" tabindex="-1">可靠性保证组件 <a class="header-anchor" href="#可靠性保证组件" aria-label="Permalink to &quot;可靠性保证组件&quot;">​</a></h4><ul><li>注册中心</li><li>监控中心</li></ul>`,93),t=[h];function o(p,n,d,c,u,s){return i(),l("div",null,t)}const m=a(r,[["render",o]]);export{q as __pageData,m as default};
